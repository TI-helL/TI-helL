# 경계 횡단하기
- 가장 단순한 형태의 경계 횡단은 저수준 클라이언트에서 고수준 서비스로 향하는 함수 호출
- 이 경우 런타임 의존성과 컴파일 타임 의존성은 모두 같은 방향, 즉 저수준 컴포넌트에서 고수준 컴포넌트로 향하게 된다.

### 저수준에서 고수준으로 횡단
![그림4](https://user-images.githubusercontent.com/24540286/140643028-d025d17b-857e-4f20-a971-79332462e08f.png)

- 제어 흐름은 왼쪽에서 오른쪽으로 경계를 횡단한다.
- Client는 Service의 함수 f()를 호출한다. 이때 Client는 Data인스턴스를 전달한다.
- 주목할 점은 **경게에서 호출되는 쪽에 Data에 대한 정의가 위치**한다.

### 고수준에서 저수준으로 횡단
- 동적 다형성을 이용하여 제어흐름과는 반대 방향으로 의존성을 역전시킬 수 있고 런타임 의존성은 컴파일 타임 의존성과는 반대가 된다.

![그림5](https://user-images.githubusercontent.com/24540286/140643022-dec4e15b-302e-4ab3-9997-a9b3d209527e.png)

- 위 그림은 이전 그림과 마찬가지로 왼쪽에서 오른쪽으로 경계를 횡단한다. 
- 고수준 Client는 Service 인터페이스를 통해 저수준인 ServiceImpl의 함수 f()를 호출한다. 
- 하지만 경계를 횡단할때 의존성은 모두 오른쪽에서 왼쪽으로, 즉 고수준 컴포넌트를 향한다는 점이다. 
- 또한 **데이터 구조의 정의가 호출하는 쪽에 위치**한다.

### 경계를 만드는 이유

경계를 만들어서 규칙적인 방식으로 구조를 분리하면 프로젝트 개발, 테스트, 배포하는 작업에 큰 도움이 된다.  
팀들은 서로의 영역에 침범하지 않은채 자신만의 컴포넌트를 독립적으로 작업할 수 있다. 


