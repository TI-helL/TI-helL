# JPA 영속성 컨텍스트
## 영속성 컨텍스트란
- 엔티티를 영구 저장하는 환경
- 애플리케이션과 데이터베이스 사이에 객체를 보관하는 가상의 데이터베이스, 캐시 같은 역할을 함
- 엔티티 매니저를 통해 저장, 조회하며 엔티티 매니저는 엔티티를 보관하고 관리한다.
## 특징
- 엔티티 매니저를 생성할 때 하나 만들어진다
- 매니저를 통해 영속성 컨텍스트에 접근하고 관리할 수 있다
## 엔티티의 생명주기
- 비영속(new/transient)
	- 영속성 컨텍스트와 관련이 없는 상태
	- Entity 객체가 만들어진 직후의 상태
- 영속(managed)
	- Entity Manager를 통해서 Entity를 영속성 컨텍스트에 저장한 상태
	- 영속성 컨텍스트에 의해 관리되는 상태
	- persist()처럼 새로 Entity객체를 저장할 때
	- JPQL이나 em.find() 처럼 DB에서 조회하여 가져오는 경우
- 준영속(detached)
	- 영속성 컨텍스트에서 엔티티를 관리하지 않을 때
	- em.detach()는 특정 Entity를 준영속 상태로 만듦
	- em.close()는 영속성 컨텍스트를 닫고, Entity들을 준영속 상태로 만듦
	- em.clear()는 영속 컨텍스트를 초기화하고 Entity들을 준영속 상태로 만듦
- 삭제(removed)
	- entity 객체를 영속성 컨텍스트와 데이터베이스에서 삭제
## 영속성 컨텍스트의 특징
- 1차 캐시
- 동일성 보장
- 트랜잭션을 지원하는 쓰기 지연
- 변경감지
- 지연로딩
- 영속성 컨텍스트는 엔티티를 식별자 값으로 구분하기에 영속상태는 반드시 식별자값을 가지고 있어야 한다
- JPA에서는 보통 트랜젝션을 커밋 하는 순간 변경된 엔티티를 데이터베이스에 반영한다. 이를 flush라고 한다
## EntityManagerFactory
- Entitymanager를 생성하는 팩토리
- 생성에 비용이 크다
- 한개만 만들어 어플리케이션 전체가 공유하도록 설계
- 여러 스레드가 동시에 접근하도록 설계되어 있고 공유 가능하다
## EntityManager
- 여러 스레드가 동시 접근 시 동시성 문제 발생
- 공유 불가
- 데이터베이스 연결이 필요한 시점까지 커넥션을 얻지 않음
## @Entity
- Entity 어노테이션이 붙는 경우 해당 클래스는 JPA가 관리한다
- name 속성을 이용하여 JPA에서 사용할 엔티티 이름을 지정할 수 있다
- 지정하지 않으면 기본값으로 클래스 이름이 사용된다