# async await 은 왜 비동기 처리 인가
[출처](https://velog.io/@yejinh/%EB%B9%84%EB%8F%99%EA%B8%B0-%ED%8C%8C%ED%97%A4%EC%B9%98%EA%B8%B0)

async await를 경험적으로 그리고 습관적으로 비동기 처리 패턴으로 인식하고 있다가 await를 하면 블록되는데 왜 비동기 패턴이라고 할까 란 의문이 들어 개념확립을 위해 조사해 보았다.

동기와 비동기를 나누는 차이는 블록이 되어 해당 작업이 끝난 후 다음 구문을 실행하느냐, 아니면 작업의 완료와 관계없이 다음 구문을 실행하느냐의 차이다. 동기는 보통의 싱글스레드의 명령형 프로그래밍에서 익숙해진 방식이다. 하지만 비동기는 익숙하지 않다. 실행순서가 확실하지 않고 잘못 처리를 하면 컨트롤을 벗어나 예기치 못한 오류를 발생시킬 가능성이 있다.

자바스크립트에서는 비동기의 개념에 익숙해 져야하는데 그 이유는 자바스크립트는 싱글 스레드 언어라는데 있다. 싱글스레드의 경우 call stack이 하나라 하나의 이벤트에서 블록되면 다른 이벤트나 작업들을 수행하지 못하는 현상이 일어나는데 이런 한계를 극복하기 위하여 비동기를 적극적으로 활용한다. (event loop) 이렇게 되면 순서에 민감한 이벤트 관계인 경우 처리의 불명확성 때문에 문제가 될 수 있는데 이를 해결해 주는 방식이 몇가지 있다.

콜백 - 순차적으로 처리해야하는 이벤트들을 순차적으로 콜백으로 넣어줌

프로미스 - pending, fulfilled, rejected, settled의 상태를 가지며 비동기 작업을 처리한다.

async-await - asyncFunction 객체를 반환하는 비동기 함수를 정의. 비동기 함수는 이벤트 루프를 통해 비동기 작업을 하는 함수를 말함 암시적으로 Promise를 반환(그러나 promise 대체의 개념이 아님).

---

[출처](https://www.daleseo.com/js-async-callback/)

비동기는 쉽게말해 호출부에서 실행결과를 기다리지 않아도 되는 함수이다.

이러한 논블록킹 이점때문에 자바스크립트와 같은 싱글 스레드 환경에서 광범위하게 사용된다.

자바스크립트에는 여러 비동기 함수가 있지만 대표적으로 setTimeout이 있다.

## 정리

async-awiat, promise는 비동기함수를 동기처럼 사용하게 하면서 왜 비동기 패턴이라고 할까에 대한 답은

비동기 패턴이 맞다. 비동기가 포함된 함수에서 비동기 이후 결과값을 처리해 주기 위해 비동기 포함 함수 내부에서만 동기화를 시켜준다.

즉 블록이 호출스택에서 블록인 상태로 있는게 아니라 이벤트 큐에 들어가있는 비동기 다음 작업이 블록되어 있는 상태이다. 비동기 작업이 끝나면 비동기 포함 함수는 테스크큐에 들어갔다가 다시 호출스택으로 올라오고 다음 작업을 실행한다.

따라서 비동기 함수를 awiat으로 블록시켰다고해서 호출스택에서 블록이 되는건 아니다.